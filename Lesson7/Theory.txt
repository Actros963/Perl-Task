       Регулярные выражения
    1. Для чего служат регулярные выражения?

    Регулярные выражения служат для обработки текста. Фактически то для чего используются регулярные выражения — это поиск и замена по шаблону.  Каждое регулярное выражение либо ищет текст (выполняет операцию поиска) либо ищет и заменяет текст(выполняет операцию замены).




    2. Какие операторы сопоставления шаблону есть в Perl? Что они делают? Что возвращают эти операторы в разных контекстах и условиях?

m/ pattern/ - ищет совпадения по шаблону
s/ pattern/replace /  -  поиск по шаблону и замена подстроки
поддерживают интерполяцию строк в паттерне

y/ / / (tr / / /) - транслитерация (замена) одного набора символов другим не поддерживает интерполяцию


    3. Что такое метасимволы, чем их поведение отличается от обычных символов в re? Какие метасимволы есть в Perl re, для чего служит каждый из них?
       
Метасимволы — это специальные символы, имеющие особый смысл в регулярных выражениях. Это следующие символы  {} [] ()  ^ $ . | * + ? - \ 
« . » Символ точка обозначает один произвольный символ в шаблоне, кроме символа перевода строки (по умолчанию).
[] - Содержат отдельные символы и диапазоны значений, в числе которых должно встречаться проверяемое значение. Совпадает только с одним из символов, но это может быть любой из символов класса. [ - начало описания символьного класса, ] - конец описания символьного класса
{} - разделенная запятой пара символов, определяющая минимальное и максимальное количество повторений(количественного квантификатора). Если опустить вторую цифру, максимальное количество совпадений элемента не ограничивается. Если убрать еще и запятую, число определяет точное количество совпадений.
() - как и в математике используются для группировки элементов выражения.
| - означает, что совпасть может либо выражение в левой части, либо в правой части    ( | ) .
^ - вначале символьного класса обозначает его инверсию. В качестве якоря ^ определяет начало строки.
$ - декларирует конец данных или до завершения строки (или окончание строки в многострочном режиме) .
* - квантификатор, означающий 0 или более вхождений
+ - квантификатор, означающий 1 или более вхождений
? - расширяет смысл метасимвола (, является также квантификатором, означающим 0 или 1 вхождение, также преобразует жадные квантификаторы в ленивые) 
\ - общий экранирующий символ, допускающий несколько вариантов применения 
-  Для удобства в символьном классе позволяет определить диапазоны.


    4. Что такое квантификаторы? Какие квантификаторы есть в Perl re, как работает каждый из них?

Часто возникает необходимость в повторении некоторых частей шаблона. Квантификатор - определитель количества повторений предыдущего элемента.
* - квантификатор, означающий 0 или более вхождений
+ - квантификатор, означающий 1 или более вхождений
? - квантификатор, обозначающий 0 или 1 вхождений элемента, то есть элемент необязателен
Квантификаторы в фигурных скобках {1,10} - разделенная запятой пара символов, определяющая минимальное и максимальное количество повторений(количественного квантификатора). Если опустить вторую цифру, максимальное количество совпадений элемента не ограничивается. Если убрать еще и запятую, число определяет точное количество совпадений.




    5. Какие есть варианты поведения квантификаторов с точки зрения размера захватываемого совпадения? Как их регулировать?
Квантификатор в шаблоне означает некоторое количество повторений предшествующего элемента. Квантификаторы +, *, ? и {,} - максимальные(жадные), они находят совпадения максимально возможной длины и неохотно уступают символы только в том случае, если это необходимо для общего совпадения шаблона. У каждого жадного квантификатора есть парный минимальный квантификатор +?, *+, ??, {,}? они довольствуются минимальным количеством символов(вместо максимально возможного)




    6. Что такое модификаторы? Какие основные модификаторы есть в Perl re, на что они влияют?

    Для регулярных выражений существует набор модификаторов, которые меняют работу поиска. Они обозначаются одиночной буквой латинского алфавита и ставятся в конце регулярного выражения, после закрывающего “/”.
      /i — символы в шаблоне соответствуют символам как верхнего, так и нижнего регистра.
      /m — по умолчанию текст обрабатывается, как однострочная символьная строка. Метасимвол начала строки '^' соответствует только началу обрабатываемого текста, в то время как метасимвол конца строки '$' соответствует концу текста. Если этот модификатор используется, метасимволы «начало строки» и «конец строки» также соответствуют позициям перед произвольным символом перевода и строки и, соответственно, после, как и в самом начале, и в самом конце строки.
/s – совпадение точки с любым символом(в том числе и с символом перевода строки) .
/x -  добавление пропусков (позволяет добавлять в регулярное выражение комментарии и другие произвольные пропуски улучшающие чтение)
модификаторы можно комбинировать.

    7. Что такое классы символов? Для чего они нужны? Как определить класс символов? Как инвертировать класс символов?

    Перечисление символов, заключенное в квадратные скобки, называется классом символов и соответствует любому из символов этого списка (но только одному). Например, класс [aeiouy] соответствует любой гласной букве английского языка. Чтобы включить в класс правую квадратную скобку, поставьте перед ней обратную косую черту или сделайте ее первым элементом перечисления.
    Диапазоны символов могут задаваться с помощью дефиса в формате вида a-z. Можно объединять несколько диапазонов. Например, [0-9a-fA-F] соответствует одной шестнадцатеричной ?цифре ?. Можно использовать обратную косую черту, чтобы экранировать дефис, который иначе будет интерпретироваться как указатель диапазона, либо поместить дефис в начале или конце класса (такой подход, возможно, снижает удобочитаемость, но является более традиционным). 
    Символ вставки ^ (или циркумфлекс, или ?крышка?, или ?стрелка вверх?) в начале перечисления символов инвертирует класс, в результате чего он соответствует любому символу, не входящему в список. (Чтобы включить в класс символ ^, не делайте его первым, а лучше попросту экранируйте его обратной косой чертой.) Например, [^aeiouy] соответствует символу, который не является гласной буквой английского языка. Однако будьте осторожны с отрицанием классов символов, поскольку вселенная символов расширяется. Например, этот класс символов соответствует согласным, а также пробелам, символам перевода строки и чему угодно (включая гласные) в кириллице, греческом и почти любом Б и этрусском.) Поэтому, возможно, будет лучше задать согласные явно, например, как [cbdfghjklmnpqrstvwxyz] или для краткости [b-df-hj-np-tv-z].другом алфавите, не говоря уже обо всех китайских, японских и корейских иероглифах. (Это также решает проблему с латинской ?y?, которая должна быть одновременно в обоих местах, что не получится при использовании ^ – дополнения класса.) 
    Внутри класса символов допускаются обычные символьные метазнаки, такие как \n, \t, \cX, \xNN, \NNN (подразумевается восьмеричное число, а не обратная ссылка), \p{YESPROP} и \N{NAME}. Кроме того, в классе символов можно использовать \b для обозначения забоя, так же как в строках, заключенных в двойные кавычки. Обычно при поиске по шаблону \b обозначает границу слова. Но утверждения нулевой ширины не имеют смысла в классах символов, поэтому в них \b возвращается к своему обычному значению в строках. В качестве границы диапазона можно использовать любой одиночный символ, будь то литеральный символ, экранированная последовательность вроде \t, шестнадцатеричный или восьмеричный код символа, или же именованный символ. 
   В символьных классах также допускается использование любых метазнаков, представляющих определенные наборы символов, включая инвертированные классы вроде \P{NOPROP}, \N, \S и \D, а также предопределенные символьные классы,описываемые ниже в этой главе (традиционные, классы Юникода или классы POSIX). Но не пытайтесь применять их в качестве границ диапазона: это бессмысленно, поэтому символ ?-? будет интерпретирован буквально. Не имеет также смысла использовать нечто, имеющее длину более одного символа. Это правило исключает \R, поскольку этот метазнак может соответствовать паре возврат каретки и перевод строки; метазнак \X, поскольку он может соответствовать нескольким идущим подряд кодовым пунктам; а также некоторые именованные последовательности \N{NAME}, эквивалентные нескольким кодам символов. 
     Все остальные метазнаки утрачивают свое особое значение, находясь в квадратных скобках. В частности, не допускается применение трех обобщающих масок: ., \X и \C. Первое часто вызывает удивление, но не имеет смысла использовать универсальный класс символов внутри ограниченного, зато часто требуется найти точку в составе класса символов, например, при поиске имен файлов. Бессмысленно также задавать квантификаторы, утверждения или чередование внутри класса символов, поскольку символы интерпретируются индивидуально. Например, [fee|fie|foe|foo] означает то же самое, что и [feio|].
  Символьный класс в квадратных скобках обычно соответствует только одному символу. По этой причине именованные последовательности Юникода не могут применяться (с пользой для дела) в классах символов в Perl v5.14. Они похожи на имена символов, но в действительности обозначают несколько символов. Например, latin capital letter a with macron and grave можно использовать в конструкции \N{...}, но фактически это имя раскрывается в символ U+0100, за которым следует символ U+0300. Внутри квадратных скобок эта именованная последовательность будет выглядеть как [\x{100}\x{300}], что наврядли отвечает вашим  желаниям. 
  Однако в областидействия модификатора /i символьныйкласс иногда может соответствовать более чем одному символу. Это обусловлено тем, что в результате полной свертки регистра символов единственный символ в строке может соответствовать нескольким символам  в шаблоне и наоборот. Например, следующее выражение истинно:
     "SS" =~ /^[\xDF]$/iu
     Причина в том, что результатом свертки регистра символа U+00DF является последовательность "ss", и результатом свертки регистра строки "SS" так.е является  последовательность "ss". Поскольку результаты свертки одинаковы, попытка сопоставления завершается успехом. Однако в инвертированных символьных классах, таких как [^\xDF], полная свертка заменяется простой сверткой, потому что иначе могут возникнуть логические противоречия. Это единственный случай, когда в Perl используется простая свертка регистра; во всех остальных случаях используется полная свертка и полное отображение регистров. 